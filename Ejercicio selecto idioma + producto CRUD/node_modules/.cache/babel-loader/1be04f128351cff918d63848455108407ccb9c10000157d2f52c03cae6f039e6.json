{"ast":null,"code":"// Servicio unificado de productos\nexport class ProductService {\n  static async getProducts(userId) {\n    // Simular delay de red para mantener la experiencia de API\n    await new Promise(resolve => setTimeout(resolve, 200));\n    const products = localStorage.getItem(`${this.baseKey}${userId}`);\n    return products ? JSON.parse(products) : [];\n  }\n  static async createProduct(product) {\n    await new Promise(resolve => setTimeout(resolve, 300));\n    const newProduct = {\n      ...product,\n      id: Date.now() + Math.random() // Asegurar ID único\n    };\n    const existingProducts = await this.getProducts(product.userId);\n    const updatedProducts = [...existingProducts, newProduct];\n    localStorage.setItem(`${this.baseKey}${product.userId}`, JSON.stringify(updatedProducts));\n    return newProduct;\n  }\n  static async updateProduct(product) {\n    await new Promise(resolve => setTimeout(resolve, 300));\n    const existingProducts = await this.getProducts(product.userId);\n    const updatedProducts = existingProducts.map(p => p.id === product.id ? product : p);\n    localStorage.setItem(`${this.baseKey}${product.userId}`, JSON.stringify(updatedProducts));\n    return product;\n  }\n  static async deleteProduct(productId, userId) {\n    await new Promise(resolve => setTimeout(resolve, 300));\n    const existingProducts = await this.getProducts(userId);\n    const updatedProducts = existingProducts.filter(p => p.id !== productId);\n    localStorage.setItem(`${this.baseKey}${userId}`, JSON.stringify(updatedProducts));\n  }\n\n  // Migrar datos existentes de los sistemas antiguos\n  static async migrateExistingData(userId) {\n    const newKey = `${this.baseKey}${userId}`;\n\n    // Si ya existen datos en el nuevo formato, no hacer nada\n    if (localStorage.getItem(newKey)) {\n      return;\n    }\n\n    // Migrar desde el sistema de la Tarea 1\n    const task1Products = localStorage.getItem(`products_${userId}`);\n    let migratedProducts = [];\n    if (task1Products) {\n      migratedProducts = JSON.parse(task1Products);\n    }\n\n    // Migrar desde el sistema de la Tarea 3\n    const task3Products = localStorage.getItem(`crud_products_${userId}`);\n    if (task3Products) {\n      const task3Data = JSON.parse(task3Products);\n      // Evitar duplicados basándose en nombre y precio\n      const existingKeys = new Set(migratedProducts.map(p => `${p.name}-${p.price}`));\n      task3Data.forEach(product => {\n        const key = `${product.name}-${product.price}`;\n        if (!existingKeys.has(key)) {\n          migratedProducts.push(product);\n        }\n      });\n    }\n\n    // Guardar en el nuevo formato\n    if (migratedProducts.length > 0) {\n      localStorage.setItem(newKey, JSON.stringify(migratedProducts));\n    }\n\n    // Limpiar datos antiguos (opcional, comentado por seguridad)\n    // localStorage.removeItem(`products_${userId}`);\n    // localStorage.removeItem(`crud_products_${userId}`);\n  }\n}\nProductService.baseKey = 'unified_products_';","map":{"version":3,"names":["ProductService","getProducts","userId","Promise","resolve","setTimeout","products","localStorage","getItem","baseKey","JSON","parse","createProduct","product","newProduct","id","Date","now","Math","random","existingProducts","updatedProducts","setItem","stringify","updateProduct","map","p","deleteProduct","productId","filter","migrateExistingData","newKey","task1Products","migratedProducts","task3Products","task3Data","existingKeys","Set","name","price","forEach","key","has","push","length"],"sources":["C:/Users/admin/Desktop/proyecto-integrado/src/shared/ProductService.ts"],"sourcesContent":["export interface Product {\r\n  id: number;\r\n  name: string;\r\n  price: number;\r\n  description: string;\r\n  photo: string; // Base64 de la imagen\r\n  userId: string;\r\n}\r\n\r\n// Servicio unificado de productos\r\nexport class ProductService {\r\n  private static baseKey = 'unified_products_';\r\n\r\n  static async getProducts(userId: string): Promise<Product[]> {\r\n    // Simular delay de red para mantener la experiencia de API\r\n    await new Promise(resolve => setTimeout(resolve, 200));\r\n    \r\n    const products = localStorage.getItem(`${this.baseKey}${userId}`);\r\n    return products ? JSON.parse(products) : [];\r\n  }\r\n\r\n  static async createProduct(product: Omit<Product, 'id'>): Promise<Product> {\r\n    await new Promise(resolve => setTimeout(resolve, 300));\r\n    \r\n    const newProduct: Product = {\r\n      ...product,\r\n      id: Date.now() + Math.random() // Asegurar ID único\r\n    };\r\n\r\n    const existingProducts = await this.getProducts(product.userId);\r\n    const updatedProducts = [...existingProducts, newProduct];\r\n    localStorage.setItem(`${this.baseKey}${product.userId}`, JSON.stringify(updatedProducts));\r\n    \r\n    return newProduct;\r\n  }\r\n\r\n  static async updateProduct(product: Product): Promise<Product> {\r\n    await new Promise(resolve => setTimeout(resolve, 300));\r\n    \r\n    const existingProducts = await this.getProducts(product.userId);\r\n    const updatedProducts = existingProducts.map(p => \r\n      p.id === product.id ? product : p\r\n    );\r\n    localStorage.setItem(`${this.baseKey}${product.userId}`, JSON.stringify(updatedProducts));\r\n    \r\n    return product;\r\n  }\r\n\r\n  static async deleteProduct(productId: number, userId: string): Promise<void> {\r\n    await new Promise(resolve => setTimeout(resolve, 300));\r\n    \r\n    const existingProducts = await this.getProducts(userId);\r\n    const updatedProducts = existingProducts.filter(p => p.id !== productId);\r\n    localStorage.setItem(`${this.baseKey}${userId}`, JSON.stringify(updatedProducts));\r\n  }\r\n\r\n  // Migrar datos existentes de los sistemas antiguos\r\n  static async migrateExistingData(userId: string): Promise<void> {\r\n    const newKey = `${this.baseKey}${userId}`;\r\n    \r\n    // Si ya existen datos en el nuevo formato, no hacer nada\r\n    if (localStorage.getItem(newKey)) {\r\n      return;\r\n    }\r\n\r\n    // Migrar desde el sistema de la Tarea 1\r\n    const task1Products = localStorage.getItem(`products_${userId}`);\r\n    let migratedProducts: Product[] = [];\r\n\r\n    if (task1Products) {\r\n      migratedProducts = JSON.parse(task1Products);\r\n    }\r\n\r\n    // Migrar desde el sistema de la Tarea 3\r\n    const task3Products = localStorage.getItem(`crud_products_${userId}`);\r\n    if (task3Products) {\r\n      const task3Data = JSON.parse(task3Products);\r\n      // Evitar duplicados basándose en nombre y precio\r\n      const existingKeys = new Set(migratedProducts.map(p => `${p.name}-${p.price}`));\r\n      \r\n      task3Data.forEach((product: Product) => {\r\n        const key = `${product.name}-${product.price}`;\r\n        if (!existingKeys.has(key)) {\r\n          migratedProducts.push(product);\r\n        }\r\n      });\r\n    }\r\n\r\n    // Guardar en el nuevo formato\r\n    if (migratedProducts.length > 0) {\r\n      localStorage.setItem(newKey, JSON.stringify(migratedProducts));\r\n    }\r\n\r\n    // Limpiar datos antiguos (opcional, comentado por seguridad)\r\n    // localStorage.removeItem(`products_${userId}`);\r\n    // localStorage.removeItem(`crud_products_${userId}`);\r\n  }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}